{"version":3,"file":"gzip-worker.js","sources":["../../node_modules/pako/lib/zlib/trees.js","../../node_modules/pako/lib/zlib/deflate.js","../../node_modules/pako/lib/utils/strings.js","../../node_modules/pako/lib/deflate.js","../../node_modules/pako/lib/utils/common.js","../../node_modules/pako/lib/zlib/adler32.js","../../node_modules/pako/lib/zlib/crc32.js","../../node_modules/pako/lib/zlib/messages.js","../../node_modules/pako/lib/zlib/zstream.js","../../src/js/gzip-worker/index.js"],"sourcesContent":["'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n                );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n","// String encode/decode helpers\n'use strict';\n\n\nvar utils = require('./common');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // use fallback for big arrays to avoid stack overflow\n  if (len < 65537) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n","'use strict';\n\n\nvar zlib_deflate = require('./zlib/deflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n","'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n","'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n","'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n","import {gzip} from 'pako/lib/deflate';\n\nself.onmessage = function(event) {\n  try {\n    var result = gzip(event.data.data).buffer;\n    self.postMessage({\n      id: event.data.id,\n      result: result\n    });\n  }\n  catch (error) {\n    self.postMessage({\n      id: event.data.id,\n      error: error.message\n    });\n  }\n};"],"names":["length","static_tree","extra_bits","extra_base","elems","max_length","has_stree","dyn_tree","max_code","stat_desc","pending_buf","pending","bi_valid","bi_buf","bl_count","heap","heap_max","opt_len","static_len","Array","MAX_BITS","LENGTH_CODES","L_CODES","LITERALS","dyn_ltree","dyn_dtree","bl_tree","last_lit","matches","utils","arraySet","window","heap_len","depth","d_buf","l_buf","l_desc","d_desc","bl_desc","BL_CODES","msg","state","avail_out","output","pending_out","next_out","total_out","_tr_flush_block","block_start","strstart","strm","avail_in","input","next_in","wrap","adler","adler32","crc32","total_in","max_chain_length","prev_length","nice_match","w_size","w_mask","prev","good_match","lookahead","match_start","window_size","hash_size","head","insert","ins_h","hash_shift","hash_mask","match_length","_tr_tally","max_lazy_match","prev_match","strategy","match_available","good_length","max_lazy","nice_length","max_chain","func","level","status","pending_buf_size","gzhead","gzindex","method","last_flush","w_bits","hash_bits","Buf16","lit_bufsize","data_type","_tr_init","Buf8","subarray","apply","shrinkBuf","options","assign","chunkSize","windowBits","memLevel","to","raw","gzip","err","ended","chunks","zlib_deflate","deflateInit2","Error","header","deflateSetHeader","dictionary","string2buf","call","Uint8Array","deflateSetDictionary","_dict_set","push","result","String","fromCharCode","Object","prototype","hasOwnProperty","Uint16Array","Int32Array","slice","arguments","shift","TypeError","set","flattenChunks","concat","setTyped","D_CODES","HEAP_SIZE","zero","MAX_MATCH","Z_NO_FLUSH","Z_FINISH","Z_OK","Z_STREAM_END","Z_DEFAULT_COMPRESSION","Z_DEFLATED","text","hcrc","extra","name","comment","time","os","charCodeAt","_tr_align","_tr_stored_block","toString","deflate","onEnd","onData","buf2binstring","deflateEnd","join","self","onmessage","data","buffer","postMessage","id","error","message"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi9ob21lL3RyYXZpcy9idWlsZC9qYWtlYXJjaGliYWxkL3N2Z29tZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIsIi9ob21lL3RyYXZpcy9idWlsZC9qYWtlYXJjaGliYWxkL3N2Z29tZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2pha2VhcmNoaWJhbGQvc3Znb21nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2pha2VhcmNoaWJhbGQvc3Znb21nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2pha2VhcmNoaWJhbGQvc3Znb21nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiLCIvaG9tZS90cmF2aXMvYnVpbGQvamFrZWFyY2hpYmFsZC9zdmdvbWcvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIsIi9ob21lL3RyYXZpcy9idWlsZC9qYWtlYXJjaGliYWxkL3N2Z29tZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcyIsIi9ob21lL3RyYXZpcy9idWlsZC9qYWtlYXJjaGliYWxkL3N2Z29tZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIi9ob21lL3RyYXZpcy9idWlsZC9qYWtlYXJjaGliYWxkL3N2Z29tZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIiwiL2hvbWUvdHJhdmlzL2J1aWxkL2pha2VhcmNoaWJhbGQvc3Znb21nL3NyYy9qcy9nemlwLXdvcmtlci9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vdmFyIFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL3ZhciBaX1JMRSAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xuLy92YXIgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbnZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xudmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxudmFyIFNUT1JFRF9CTE9DSyA9IDA7XG52YXIgU1RBVElDX1RSRUVTID0gMTtcbnZhciBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxudmFyIE1JTl9NQVRDSCAgICA9IDM7XG52YXIgTUFYX01BVENIICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbnZhciBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbnZhciBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxudmFyIFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbnZhciBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXTtcblxudmFyIGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdO1xuXG52YXIgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XTtcblxudmFyIGJsX29yZGVyID1cbiAgWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxudmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc3RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxudmFyIHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpO1xuemVybyhzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG52YXIgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbnZhciBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyhfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbnZhciBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpO1xuemVybyhfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTKTtcbnplcm8oYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufVxuXG5cbnZhciBzdGF0aWNfbF9kZXNjO1xudmFyIHN0YXRpY19kX2Rlc2M7XG52YXIgc3RhdGljX2JsX2Rlc2M7XG5cblxuZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHtcbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7XG4gIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXS8qLkNvZGUqLywgdHJlZVtjICogMiArIDFdLyouTGVuKi8pO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIHZhciBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIHZhciBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICB2YXIgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgdmFyIGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIHZhciBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICB2YXIgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgdmFyIGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgdmFyIG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXS8qLkxlbiovID0gMDsgLyogcm9vdCBvZiB0aGUgaGVhcCAqL1xuXG4gIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20gKiAyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KVxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIHZhciBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5mdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHtcbiAgdmFyIG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICB2YXIgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICB2YXIgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5mdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHtcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgIG4rKykgeyBzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyAgbisrKSB7IHMuZHluX2R0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIGJpX3dpbmR1cChzKVxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcilcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHtcbiAgdmFyIF9uMiA9IG4gKiAyO1xuICB2YXIgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgdmFyIHYgPSBzLmhlYXBba107XG4gIHZhciBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn1cblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyB2YXIgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5mdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgdmFyIGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICB2YXIgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgdmFyIGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIHZhciBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIHZhciBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICB2YXIgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHZhciBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkRhZCovID0gdHJlZVttICogMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5mdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5mdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykge1xuICB2YXIgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgdmFyIHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsYWNrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJ3aGl0ZSBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5mdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHtcbiAgLyogYmxhY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxhY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICB2YXIgYmxhY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIHZhciBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibGFjay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcIndoaXRlLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59XG5cblxudmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIF90cl9pbml0KHMpXG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5mdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX3RyX2FsaWduKHMpIHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIHZhciBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL3ZhciBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn1cblxuZXhwb3J0cy5fdHJfaW5pdCAgPSBfdHJfaW5pdDtcbmV4cG9ydHMuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7XG5leHBvcnRzLl90cl9mbHVzaF9ibG9jayAgPSBfdHJfZmx1c2hfYmxvY2s7XG5leHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTtcbmV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgdHJlZXMgICA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBtc2cgICAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbnZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbi8vdmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xuLy92YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xuLy92YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuXG4vKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbi8vdmFyIFpfTk9fQ09NUFJFU1NJT04gICAgICA9IDA7XG4vL3ZhciBaX0JFU1RfU1BFRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9CRVNUX0NPTVBSRVNTSU9OICAgID0gOTtcbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxuXG52YXIgWl9GSUxURVJFRCAgICAgICAgICAgID0gMTtcbnZhciBaX0hVRkZNQU5fT05MWSAgICAgICAgPSAyO1xudmFyIFpfUkxFICAgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4vL3ZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuLy92YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfTUVNX0xFVkVMID0gODtcblxuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbnZhciBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgTUlOX01BVENIID0gMztcbnZhciBNQVhfTUFUQ0ggPSAyNTg7XG52YXIgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxudmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcblxudmFyIElOSVRfU1RBVEUgPSA0MjtcbnZhciBFWFRSQV9TVEFURSA9IDY5O1xudmFyIE5BTUVfU1RBVEUgPSA3MztcbnZhciBDT01NRU5UX1NUQVRFID0gOTE7XG52YXIgSENSQ19TVEFURSA9IDEwMztcbnZhciBCVVNZX1NUQVRFID0gMTEzO1xudmFyIEZJTklTSF9TVEFURSA9IDY2NjtcblxudmFyIEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG52YXIgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbnZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG52YXIgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbnZhciBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkge1xuICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdO1xuICByZXR1cm4gZXJyb3JDb2RlO1xufVxuXG5mdW5jdGlvbiByYW5rKGYpIHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn1cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7XG4gIHZhciBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICB2YXIgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHtcbiAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59XG5cblxuZnVuY3Rpb24gcHV0X2J5dGUocywgYikge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5mdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7XG4gIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHtcbiAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICB2YXIgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgdmFyIGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICB2YXIgd21hc2sgPSBzLndfbWFzaztcbiAgdmFyIHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICB2YXIgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIHZhciBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHtcbiAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTtcbiAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICB2YXIgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgdmFyIHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICB2YXIgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICB2YXIgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG5cbiAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTtcbiAgLy9zLT5wZW5kaW5nX2J1ZiA9ICh1Y2hmICopIG92ZXJsYXk7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpO1xuICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgLy9zLT5sX2J1ZiA9IHMtPnBlbmRpbmdfYnVmICsgKDErc2l6ZW9mKHVzaCkpKnMtPmxpdF9idWZzaXplO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7XG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBvbGRfZmx1c2gsIHM7XG4gIHZhciBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICB2YXIgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgdmFyIGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7XG4gIHZhciBzdGF0dXM7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHM7XG4gIHZhciBzdHIsIG47XG4gIHZhciB3cmFwO1xuICB2YXIgYXZhaWw7XG4gIHZhciBuZXh0O1xuICB2YXIgaW5wdXQ7XG4gIHZhciB0bXBEaWN0O1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpO1xuICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xuZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG4iLCIvLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmlcbi8vXG52YXIgU1RSX0FQUExZX09LID0gdHJ1ZTtcbnZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbIDAgXSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9PSyA9IGZhbHNlOyB9XG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOyB9XG5cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpO1xuZm9yICh2YXIgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXIgKHVzZWQgaW4gMiBwbGFjZXMpXG5mdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7XG4gIC8vIHVzZSBmYWxsYmFjayBmb3IgYmlnIGFycmF5cyB0byBhdm9pZCBzdGFjayBvdmVyZmxvd1xuICBpZiAobGVuIDwgNjU1MzcpIHtcbiAgICBpZiAoKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LKSB8fCAoIWJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfT0spKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGlscy5zaHJpbmtCdWYoYnVmLCBsZW4pKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLy8gQ29udmVydCBieXRlIGFycmF5IHRvIGJpbmFyeSBzdHJpbmdcbmV4cG9ydHMuYnVmMmJpbnN0cmluZyA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcoYnVmLCBidWYubGVuZ3RoKTtcbn07XG5cblxuLy8gQ29udmVydCBiaW5hcnkgc3RyaW5nICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuYmluc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KHN0ci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbmV4cG9ydHMuYnVmMnN0cmluZyA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgaSwgb3V0LCBjLCBjX2xlbjtcbiAgdmFyIGxlbiA9IG1heCB8fCBidWYubGVuZ3RoO1xuXG4gIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTtcblxuICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGMgPSBidWZbaSsrXTtcbiAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuIC0gMTsgY29udGludWU7IH1cblxuICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgIGNfbGVuLS07XG4gICAgfVxuXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBjIC09IDB4MTAwMDA7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7XG59O1xuXG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG5leHBvcnRzLnV0Zjhib3JkZXIgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIHBvcztcblxuICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDtcbiAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICBwb3MgPSBtYXggLSAxO1xuICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMHhDMCkgPT09IDB4ODApIHsgcG9zLS07IH1cblxuICAvLyBWZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICBpZiAocG9zIDwgMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIGJ1ZmZlciBpcyB0b28gc21hbGwsXG4gIC8vIHJldHVybiBtYXggdG9vLlxuICBpZiAocG9zID09PSAwKSB7IHJldHVybiBtYXg7IH1cblxuICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvZGVmbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG5cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcblxudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxudmFyIFpfREVGTEFURUQgID0gODtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIERlZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tkZWZsYXRlXV0sXG4gKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBEZWZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tEZWZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXlcbiAqXG4gKiBDb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tEZWZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tEZWZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBkZWZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogWW91IHdpbGwgbm90IG5lZWQgaXQgaW4gcmVhbCBsaWZlLCBiZWNhdXNlIGRlZmxhdGUgZXJyb3JzXG4gKiBhcmUgcG9zc2libGUgb25seSBvbiB3cm9uZyBvcHRpb25zIG9yIGJhZCBgb25EYXRhYCAvIGBvbkVuZGBcbiAqIGN1c3RvbSBoYW5kbGVycy5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0RlZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IERlZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgZGVmbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGBsZXZlbGBcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBtZW1MZXZlbGBcbiAqIC0gYHN0cmF0ZWd5YFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgZGVmbGF0ZVxuICogLSBgZ3ppcGAgKEJvb2xlYW4pIC0gY3JlYXRlIGd6aXAgd3JhcHBlclxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqIC0gYGhlYWRlcmAgKE9iamVjdCkgLSBjdXN0b20gaGVhZGVyIGZvciBnemlwXG4gKiAgIC0gYHRleHRgIChCb29sZWFuKSAtIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHRcbiAqICAgLSBgdGltZWAgKE51bWJlcikgLSBtb2RpZmljYXRpb24gdGltZSwgdW5peCB0aW1lc3RhbXBcbiAqICAgLSBgb3NgIChOdW1iZXIpIC0gb3BlcmF0aW9uIHN5c3RlbSBjb2RlXG4gKiAgIC0gYGV4dHJhYCAoQXJyYXkpIC0gYXJyYXkgb2YgYnl0ZXMgd2l0aCBleHRyYSBkYXRhIChtYXggNjU1MzYpXG4gKiAgIC0gYG5hbWVgIChTdHJpbmcpIC0gZmlsZSBuYW1lIChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBjb21tZW50YCAoU3RyaW5nKSAtIGNvbW1lbnQgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGhjcmNgIChCb29sZWFuKSAtIHRydWUgaWYgaGVhZGVyIGNyYyBzaG91bGQgYmUgYWRkZWRcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGRlZmxhdGUgPSBuZXcgcGFrby5EZWZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBkZWZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBkZWZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChkZWZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoZGVmbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coZGVmbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBEZWZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKSByZXR1cm4gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBsZXZlbDogWl9ERUZBVUxUX0NPTVBSRVNTSU9OLFxuICAgIG1ldGhvZDogWl9ERUZMQVRFRCxcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDE1LFxuICAgIG1lbUxldmVsOiA4LFxuICAgIHN0cmF0ZWd5OiBaX0RFRkFVTFRfU1RSQVRFR1ksXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKG9wdC5nemlwICYmIChvcHQud2luZG93Qml0cyA+IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDE2O1xuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC5sZXZlbCxcbiAgICBvcHQubWV0aG9kLFxuICAgIG9wdC53aW5kb3dCaXRzLFxuICAgIG9wdC5tZW1MZXZlbCxcbiAgICBvcHQuc3RyYXRlZ3lcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIGlmIChvcHQuaGVhZGVyKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLCBvcHQuaGVhZGVyKTtcbiAgfVxuXG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIHZhciBkaWN0O1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIGRpY3QgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpY3QgPSBvcHQuZGljdGlvbmFyeTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0KTtcblxuICAgIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGljdF9zZXQgPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogRGVmbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGEuIFN0cmluZ3Mgd2lsbCBiZVxuICogICBjb252ZXJ0ZWQgdG8gdXRmOCBieXRlIHNlcXVlbmNlLlxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0RlZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBhcnJheSBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IFpfRklOSVNIIDogWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgX21vZGUpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSCkpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9uRGF0YShzdHJpbmdzLmJ1ZjJiaW5zdHJpbmcodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKTtcblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBaX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IFpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGRlZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIG9uY2UgYWZ0ZXIgeW91IHRlbGwgZGVmbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBaX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogZGVmbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ29tcHJlc3MgYGRhdGFgIHdpdGggZGVmbGF0ZSBhbGdvcml0aG0gYW5kIGBvcHRpb25zYC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBsZXZlbFxuICogLSB3aW5kb3dCaXRzXG4gKiAtIG1lbUxldmVsXG4gKiAtIHN0cmF0ZWd5XG4gKiAtIGRpY3Rpb25hcnlcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBkYXRhID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhwYWtvLmRlZmxhdGUoZGF0YSkpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBkZWZsYXRvciA9IG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIGRlZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChkZWZsYXRvci5lcnIpIHsgdGhyb3cgZGVmbGF0b3IubXNnIHx8IG1zZ1tkZWZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGRlZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGRlZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBkZWZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIGd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbZGVmbGF0ZV1dLCBidXQgY3JlYXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkIG9mXG4gKiBkZWZsYXRlIG9uZS5cbiAqKi9cbmZ1bmN0aW9uIGd6aXAoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuZ3ppcCA9IHRydWU7XG4gIHJldHVybiBkZWZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlID0gZGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZVJhdyA9IGRlZmxhdGVSYXc7XG5leHBvcnRzLmd6aXAgPSBnemlwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUWVBFRF9PSyA9ICAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5mdW5jdGlvbiBfaGFzKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24gKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxudmFyIGZuVHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBvcmRpbmFyeSBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICAgIGxlbiA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGpvaW4gY2h1bmtzXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBwb3MgPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmblVudHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpO1xuICB9XG59O1xuXG5cbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24pIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gVWludDhBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgMDogICAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTtcbiIsImltcG9ydCB7Z3ppcH0gZnJvbSAncGFrby9saWIvZGVmbGF0ZSc7XG5cbnNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcmVzdWx0ID0gZ3ppcChldmVudC5kYXRhLmRhdGEpLmJ1ZmZlcjtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgIGlkOiBldmVudC5kYXRhLmlkLFxuICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICB9KTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgIGlkOiBldmVudC5kYXRhLmlkLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICB9KTtcbiAgfVxufTsiXSwibmFtZXMiOlsibGVuZ3RoIiwic3RhdGljX3RyZWUiLCJleHRyYV9iaXRzIiwiZXh0cmFfYmFzZSIsImVsZW1zIiwibWF4X2xlbmd0aCIsImhhc19zdHJlZSIsImR5bl90cmVlIiwibWF4X2NvZGUiLCJzdGF0X2Rlc2MiLCJwZW5kaW5nX2J1ZiIsInBlbmRpbmciLCJiaV92YWxpZCIsImJpX2J1ZiIsImJsX2NvdW50IiwiaGVhcCIsImhlYXBfbWF4Iiwib3B0X2xlbiIsInN0YXRpY19sZW4iLCJBcnJheSIsIk1BWF9CSVRTIiwiTEVOR1RIX0NPREVTIiwiTF9DT0RFUyIsIkxJVEVSQUxTIiwiZHluX2x0cmVlIiwiZHluX2R0cmVlIiwiYmxfdHJlZSIsImxhc3RfbGl0IiwibWF0Y2hlcyIsInV0aWxzIiwiYXJyYXlTZXQiLCJ3aW5kb3ciLCJoZWFwX2xlbiIsImRlcHRoIiwiZF9idWYiLCJsX2J1ZiIsImxfZGVzYyIsImRfZGVzYyIsImJsX2Rlc2MiLCJCTF9DT0RFUyIsIm1zZyIsInN0YXRlIiwiYXZhaWxfb3V0Iiwib3V0cHV0IiwicGVuZGluZ19vdXQiLCJuZXh0X291dCIsInRvdGFsX291dCIsIl90cl9mbHVzaF9ibG9jayIsImJsb2NrX3N0YXJ0Iiwic3Ryc3RhcnQiLCJzdHJtIiwiYXZhaWxfaW4iLCJpbnB1dCIsIm5leHRfaW4iLCJ3cmFwIiwiYWRsZXIiLCJhZGxlcjMyIiwiY3JjMzIiLCJ0b3RhbF9pbiIsIm1heF9jaGFpbl9sZW5ndGgiLCJwcmV2X2xlbmd0aCIsIm5pY2VfbWF0Y2giLCJ3X3NpemUiLCJ3X21hc2siLCJwcmV2IiwiZ29vZF9tYXRjaCIsImxvb2thaGVhZCIsIm1hdGNoX3N0YXJ0Iiwid2luZG93X3NpemUiLCJoYXNoX3NpemUiLCJoZWFkIiwiaW5zZXJ0IiwiaW5zX2giLCJoYXNoX3NoaWZ0IiwiaGFzaF9tYXNrIiwibWF0Y2hfbGVuZ3RoIiwiX3RyX3RhbGx5IiwibWF4X2xhenlfbWF0Y2giLCJwcmV2X21hdGNoIiwic3RyYXRlZ3kiLCJtYXRjaF9hdmFpbGFibGUiLCJnb29kX2xlbmd0aCIsIm1heF9sYXp5IiwibmljZV9sZW5ndGgiLCJtYXhfY2hhaW4iLCJmdW5jIiwibGV2ZWwiLCJzdGF0dXMiLCJwZW5kaW5nX2J1Zl9zaXplIiwiZ3poZWFkIiwiZ3ppbmRleCIsIm1ldGhvZCIsImxhc3RfZmx1c2giLCJ3X2JpdHMiLCJoYXNoX2JpdHMiLCJCdWYxNiIsImxpdF9idWZzaXplIiwiZGF0YV90eXBlIiwiX3RyX2luaXQiLCJCdWY4Iiwic3ViYXJyYXkiLCJhcHBseSIsInNocmlua0J1ZiIsIm9wdGlvbnMiLCJhc3NpZ24iLCJjaHVua1NpemUiLCJ3aW5kb3dCaXRzIiwibWVtTGV2ZWwiLCJ0byIsInJhdyIsImd6aXAiLCJlcnIiLCJlbmRlZCIsImNodW5rcyIsInpsaWJfZGVmbGF0ZSIsImRlZmxhdGVJbml0MiIsIkVycm9yIiwiaGVhZGVyIiwiZGVmbGF0ZVNldEhlYWRlciIsImRpY3Rpb25hcnkiLCJzdHJpbmcyYnVmIiwiY2FsbCIsIlVpbnQ4QXJyYXkiLCJkZWZsYXRlU2V0RGljdGlvbmFyeSIsIl9kaWN0X3NldCIsInB1c2giLCJyZXN1bHQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIlVpbnQxNkFycmF5IiwiSW50MzJBcnJheSIsInNsaWNlIiwiYXJndW1lbnRzIiwic2hpZnQiLCJUeXBlRXJyb3IiLCJzZXQiLCJmbGF0dGVuQ2h1bmtzIiwiY29uY2F0Iiwic2V0VHlwZWQiLCJEX0NPREVTIiwiSEVBUF9TSVpFIiwiemVybyIsIk1BWF9NQVRDSCIsIlpfTk9fRkxVU0giLCJaX0ZJTklTSCIsIlpfT0siLCJaX1NUUkVBTV9FTkQiLCJaX0RFRkFVTFRfQ09NUFJFU1NJT04iLCJaX0RFRkxBVEVEIiwidGV4dCIsImhjcmMiLCJleHRyYSIsIm5hbWUiLCJjb21tZW50IiwidGltZSIsIm9zIiwiY2hhckNvZGVBdCIsIl90cl9hbGlnbiIsIl90cl9zdG9yZWRfYmxvY2siLCJ0b1N0cmluZyIsImRlZmxhdGUiLCJvbkVuZCIsIm9uRGF0YSIsImJ1ZjJiaW5zdHJpbmciLCJkZWZsYXRlRW5kIiwiam9pbiIsInNlbGYiLCJvbm1lc3NhZ2UiLCJkYXRhIiwiYnVmZmVyIiwicG9zdE1lc3NhZ2UiLCJpZCIsImVycm9yIiwibWVzc2FnZSJdLCJtYXBwaW5ncyI6InlCQTBDQSxhQUFtQixLQUFFLEdBQUksR0FBTSxFQUFJQSxNQUFoQixDQUF3QyxDQUFULEtBQS9CLEVBQTZDLEtBQVcsQ0FBTSxDQTJIakYscUJBQWdGLENBRTlFLEtBQUtDLFdBQUwsRUFGOEUsQ0FHOUUsS0FBS0MsVUFBTCxFQUg4RSxDQUk5RSxLQUFLQyxVQUFMLEVBSjhFLENBSzlFLEtBQUtDLEtBQUwsRUFMOEUsQ0FNOUUsS0FBS0MsVUFBTCxFQU44RSxDQVM5RSxLQUFLQyxTQUFMLENBQW9CLEdBQWUsRUFBWU4sTUFDaEQsQ0FRRCxlQUF1QyxDQUNyQyxLQUFLTyxRQUFMLEVBRHFDLENBRXJDLEtBQUtDLFFBQUwsQ0FBZ0IsQ0FGcUIsQ0FHckMsS0FBS0MsU0FBTCxFQUNELENBSUQsYUFBc0IsQ0FDcEIsTUFBYyxJQUFQLEdBQWEsS0FBYixDQUFnQyxHQUFXLEtBQU8sSUFBUyxDQUFoQixD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"}